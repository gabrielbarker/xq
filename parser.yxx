%skeleton "lalr1.cc"
%require  "3.0"

%code requires{
  namespace yy {
    class Lexer;  /* Generated by reflex with namespace=yy lexer=Lexer */
  }

  #include "xml.hpp"
}

%locations
%define parse.trace

%parse-param { yy::Lexer& lexer }  /* Construct parser object with lexer */
%parse-param { XML::Tag** root }  /* To pass AST root back to driver */

%code{
    #include "lex.yy.h"
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
    // void dump(XML::Tag* n);
}

%union {
    char* str;
    XML::Tag* node;
    XML::Children* children;
    XML::Attributes* attributes;
}

// The following token values are actually used
%token <str> WORD WORDS STRING
%token LANGLE RANGLE SLASH EQ

// Abstract syntax tree nodes
%type <node> program tag 
%type <children> tags
%type <str> open close
%type <attributes> attributes

/* // Precedence.  We are using an ambiguous expression grammar
// for compactness.  We declare operator precedence from lowest
// to highest, with associativity, e.g., MINUS is left_ associative
// so a-b-c is (a-b)-c and not a-(b-c).
// a + b < c + d and x < y is (((a+b)<(c+d)) and (x<y))
// not a < b and b < c is (not (a < b)) and (b < c)
//
%left AND OR
%left NOT
%nonassoc LESS GREATER ATMOST ATLEAST EQUALS
%left MINUS PLUS
%left TIMES DIV */

%%

/* Root of the grammar is "program".  A program
 * is a non-empty sequence of assignments or expressions.
 */
program: tag  { *root = $1; } ;

open: LANGLE WORD { $$ = $2; };

attributes: attributes WORD EQ STRING { $$ = $1; $$->set($2, $4); }
          | { $$ = new XML::Attributes(); }
          ;

close: LANGLE SLASH WORD RANGLE { $$ = $3; };



tags: tags tag { $$ = $1; $1->add($2); }
    | { $$ = new XML::Children(); }
    ;

tag: open attributes RANGLE WORD close { 
    $$ = new XML::Tag(); 
    $$->setName($1); 
    $$->setAttributes($2->map());
    $$->setValue($4); 
  }
   | open attributes RANGLE WORDS close { 
    $$ = new XML::Tag(); 
    $$->setName($1); 
    $$->setAttributes($2->map());
    $$->setValue($4); 
  }
   | open attributes RANGLE tags close { 
    $$ = new XML::Tag(); 
    $$->setName($1); 
    $$->setAttributes($2->map());
    $$->setChildren($4->tags()); 
  }
   ;

%%

void yy::parser::error(const location_type& loc, const std::string& msg)
{
  std::cout << msg << std::endl;
}